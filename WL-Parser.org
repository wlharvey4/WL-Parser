# -*- mode:org; fill-column:79; -*-

#+title:WL-Parser
#+subtitle:{{{version}}} ({{{date}}})
#+author:LOLH
#+date:2019-10-04 08:03
#+macro:version Version 0.0.5

#+begin_src elisp :results silent :exports results
(org-babel-tangle-file "WL-Parser.org")
#+end_src

* Introduction
  :PROPERTIES:
  :unnumbered: t
  :END:
The program parses worklog daily and yearly files into an object.

* Install the WL-Parser Package

The following shell scripts install the projectâ€™s ~package.json~ file, install
~jest~ as a development dependency, install all ~node~ dependencies, and
finally adds a =test= script to the ~package.json~.

** Install ~package.json~
#+caption:Install the WL-Parser Package and Dependencies
#+name:install-wl-parser-package-and-dependencies
#+header: :results output :exports both
#+begin_src sh
yarn init -yp
yarn add --dev jest
#+end_src

** Add a =test= Script to ~package.json~
#+caption:Add /tests/ script to ~package.json~
#+name:add-tests-script-to-package.json
#+header: :results output :exports both
#+begin_src js
const fs = require('fs');
const package = JSON.parse(fs.readFileSync('package.json', 'utf8'));
package.scripts = {"tests": "jest"};
fs.writeFileSync('package.json', JSON.stringify(package, null, 2));
#+end_src

#+caption:The ~package.json~ file with added /tests/ script
#+begin_src sh :results output :exports both
cat package.json
#+end_src

* The WLParser Class
A proper worklog entry conforms to the following structure:

#+begin_example
1. datetime start: 2019-01-31T10:54:00
2. \tcase: 190301
3. \t\tSUBJECT --- VERB
4. \t\t\tTYPE: e.g. TIME | EXPENSE | ...
5. \s------------------------------------------------------------------------------
6. \sDETAIL : possible multiple lines in length
   \sDETAIL ...
7. \s------------------------------------------------------------------------------
8. datetime end: 2019-01-31T11:00:00
9. record separator: \n
#+end_example

*Note:* Record entries must be separated by a blank line.

** Create the ~wl_re~ Regular Expressions
The following code sets up the individual regular expressions for each
component of a worklog entry.  The export object is the combined regular
expression for the entire worklog entry.

If an entry requires special processing at the time of parsing, as does the
=message= entry below, which needs newlines stripped, place the component name
in an array in position 0, and a lambda expression to run the entry through in
position 1.  The WL_Parser will look for an object in each component entry, and
if one is found, run the entry through the lambda expression.

*Note:* The true structure of the 2nd, 3rd, and 4th lines include one, two and
three tabs, respectively, at the beginning of the lines, but for the sake of
avoiding problems with different editors handling SPACES vs TABS, I am using
only SPACES, and not TABS.

#+caption:Regular Expression Representing a Worklog Entry
#+name:regexp-worklog-entry
#+header: :mkdirp yes
#+begin_src js -n :tangle src/wl_re.js
  /* wl_re.js */

  const WL_COMPONENTS = [
    'original',
    'start_date',
    'start_time',
    'caseno',
    'subject',
    'verb',
    'type',
    ['message', m => m.replace(/\n/gm, '')],
    'end_date',
    'end_time',
    'record_sep'
  ];

  /* REGEXP COMPONENTS OF A WORKLOG ENTRY */
  const DATETIME_RE = '^(\\d{4}-\\d{2}-\\d{2})T(\\d{2}:\\d{2}:00)$\\n';
  const CASE_RE     = '^\\s+(.{6})$\\n';
  const SUBJ_VERB_RE= '^\\s+(.*?) --- (.*?)$\\n';
  const TYPE_RE     = '^\\s+(.*?)$\\n';
  const MESSAGE_RE  = '^\\s-{78}$\\n^\\s(.*?)^\\s-{78}$\\n'
  const RECORD_SEP  = '^(\\n)';

  /* COMBINED REGULAR EXPRESSION FOR ENTIRE WORKLOG ENTRY */
  const wl_re = new RegExp(
    DATETIME_RE  +
    CASE_RE      +
    SUBJ_VERB_RE +
    TYPE_RE      +
    MESSAGE_RE   +
    DATETIME_RE  +
    RECORD_SEP,
    'ms'
  );

  module.exports = {wl_re, WL_COMPONENTS};
#+end_src

** Create the ~wl_parser~ Module
The following class receives a worklog record as a string and uses the ~wl_re~
module to parse and return its components.  Note that the parser must check
each WL_COMPONENT entry for an object (array in this case), and if one is
found, then it runs the entry through the supplied lambda expression in the
array's second position.

#+caption:The ~wl_parser~ Module
#+name:wl_parser-module
#+header: :mkdirp yes
#+begin_src js :tangle src/wl_parser.js
  /* wl_parser.js */

  const {wl_re, WL_COMPONENTS} = require('./wl_re.js');

  class WLParser {

      constructor(wl_record) {
          const parsed = wl_re.exec(wl_record);

          if (!parsed) { 
              throw ReferenceError(`wl_record:\n${wl_record}\nfailed to parse`)
          }

          this._parsed_record = parsed.map((e,i) => {
              let key = WL_COMPONENTS[i];
              if (typeof key === 'object') {  // see WL_COMPONENTS[7]
                  e = WL_COMPONENTS[i][1](e); // run e through the supplied lambda function
                  key = WL_COMPONENTS[i][0];  // use the string key
              }

              const components = {};
              components[key] = e;
              return components;
          });
      }

      get entry() {
          return Object.assign({}, this._parsed_record);
      }
  }

  module.exports = WLParser;
#+end_src

#+RESULTS: wl_parser-module

** Test the ~wl_parser~ Module

*NOTE:* The following sample records sometimes shift to the right by a couple
of spaces upon a save of the file.  If a test record fails to parse, make sure
there is no space before either datetime and there is one space only before the
message detail and enclosing dotted lines.

#+header: :mkdirp yes
#+begin_src js -n :tangle __tests__/wl_parser.test.js
      const Parser = require('../src/wl_parser');

      const STR=
  `2019-01-02T10:30:00
            180704
                    STATUS UPDATE --- SW PHONE
                            TIME
   ------------------------------------------------------------------------------
   Received call from SW; Client has been removed from his housing; SW is
   picking him up and will be finding a new place for him to stay.
   ------------------------------------------------------------------------------
  2019-01-02T10:36:00

  2019-01-02T14:00:00
          180203
                  NEGOTIATION --- CLIENT PHONE
                          TIME
   ------------------------------------------------------------------------------
   Spoke with Client about terms of counter-offer.  Will propose flat amount of
   $900 per month.
   ------------------------------------------------------------------------------
  2019-01-02T14:30:00

  `;

  describe('The WLParser', () => {
      test('throws with an invalid entry', () => {
          expect(() => {
              new Parser('abc')
          }).toThrow(ReferenceError);
      });
      test('does not throw with a valid entry', () => {
          expect(() => {
              new Parser(STR);
          }).not.toThrow();
      });
  });
#+end_src

** Check the ~wl_re~ Regular Expression Implementation
#+caption:Check WL_RE
#+name:check-wl_re
#+header: :mkdirp yes
#+begin_src js -n :tangle src/check.js
  const {wl_re, WL_COMPONENTS} = require('../src/wl_re.js');

  const STR=`2019-01-02T10:30:00
          180704
                  STATUS UPDATE --- SW PHONE
                          TIME
   ------------------------------------------------------------------------------
   Received call from SW; Client has been removed from his housing; SW is
   picking him up and will be finding a new place for him to stay.
   ------------------------------------------------------------------------------
  2019-01-02T10:36:00

  2019-01-02T14:00:00
          180203
                  NEGOTIATION --- CLIENT PHONE
                          TIME
   ------------------------------------------------------------------------------
   Spoke with Client about terms of counter-offer.  Will propose flat amount of
   $900 per month.
   ------------------------------------------------------------------------------
   2019-01-02T14:30:00

  `;

  const result = wl_re.exec(STR);

  const start_date = RegExp.$1;
  const start_time = RegExp.$2;
  const caseno     = RegExp.$3;
  const subject    = RegExp.$4;
  const verb       = RegExp.$5;
  const type       = RegExp.$6;
  const message    = RegExp.$7;
  const end_date   = RegExp.$8;
  const end_time   = RegExp.$9;
  const record_sep = result[10];

  const mess_sep_re = /\n/gm;
  const mess = message.replace(mess_sep_re, '');

  console.log(STR)
  console.log('--------------');
  console.log(`Start: ${start_date} T ${start_time}\nCase No: ${caseno}\nSubject: ${subject}\tVerb: ${verb}\nType: ${type}`);
  console.log(`${mess}`);
  console.log(`End: ${end_date} T ${end_time}`);
  console.log(`RS: ${record_sep}`);
  console.log('--------------');
#+end_src

* The WLReader Class
The Log Reader is a Stream Reader that reads records from a log file given the
name of the log file and a record separator.  The Reader emits a signal with
each record read.  The Reader emits a finished signal at the conclusion of
reading all records.

** Implementation of the WLReader

#+caption:Implementation of the WLReader
#+name:WLReader-class
#+header: :mkdirp yes
#+begin_src js -n :tangle src/wl_reader.js
  /* log_reader.js */
  const EventEmitter = require('events').EventEmitter;
  const fs = require('fs');
  const rl = require('readline');

  class WLReader extends EventEmitter {
      constructor(logfile, rec_sep) {
          super();
          this._logfile = logfile;
          this._rec_sep = rec_sep;
          this._entry = '';

          if (!fs.existsSync(logfile)) {
              throw new Error(`Logfile '${logfile}' does not exist`);
              process.exit(1);
          }

          this._rs = fs.createReadStream(logfile, {
              encoding: 'utf8',
              emitClose: true,
          });
      }

      read() {
          const rl_interface = rl.createInterface({
              input: this._rs
          });

          rl_interface.on('line', line => {
              this._entry += (line + '\n');    

              if (this._rec_sep.test(line)) {
                  this.emit('entry', this._entry);
                  this._entry = '';
              }

          }).on('close', () => {
              this.emit('done');

          }).on('error', err => {
              console.error(`ERROR: ${err.message}`);

          });
      }
  }

module.exports = WLReader;
#+end_src

** Testing the WLReader

#+caption:Testing the WLReader
#+name:test-log-reader
#+begin_src js -n :tangle __tests__/wl_reader.test.js
  /* log_reader.test.js */

  const path    = require('path');
  const WLR     = require('../src/wl_reader');
  const WLParser= require('../src/wl_parser');
  const WORKLOG = process.env.WORKLOG;
  const LOGNAME = 'worklog.2019.otl';
  const REC_SEP = /^$/;

  if (!WORKLOG) throw new ReferenceError('The environment variable `WORKLOG` is not defined');

  const logfile = path.format({
      dir:  WORKLOG,
      name: LOGNAME
  });

  describe('The WLReader', () => {
      test('reads a log file', () => {
          expect(() => {
              new WLR(logfile, REC_SEP)
          }).not.toThrow();
      });
      test('prints a log file', done => {
          let entry;
          const wlr = new WLR(logfile, REC_SEP);
          wlr.on('entry', entry => {
              entry = new WLParser(entry);
          }).on('done', done);

          wlr.read();
      });
  });
#+end_src

* The DataLogger
The DataLogger class receives each of the worklog records from the LogReader,
parses the record using the WLParser, and emits messages for each type of
record found, such as TIME, EXPENSE, PAYMENT, etc.  The record itself is sent
with each message.

** Implementation of the DataLogger

#+caption:Implementation of the DataLogger class
#+name:DataLogger-class
#+begin_src js -n :tangle src/data_logger.js
  /* data_logger.js */

  const EventEmitter = require('events').EventEmitter;
#+end_src
w
* Makefile
:PROPERTIES:
:appendix: t
:END:
#+caption:Makefile
#+name:Makefile
#+begin_src make -n :tangle Makefile
.PHONY:	clean clean-world check

clean:
	-rm *~

clean-world:	clean
	-rm *.{info,texi,json,lock}
	-rm -rf src/ __tests__/ node_modules/

check:
	node src/check.js
#+end_src

* Concept Index
  :PROPERTIES:
  :unnumbered: 5
  :index:    cp
  :END:

* Macro Definitions                                                :noexport:
#+macro:heading @@texinfo:@heading @@$1
#+macro:subheading @@texinfo:@subheading @@$1
#+macro:noindent @@texinfo:@noindent @@

* Local Variables                                                  :noexport:
# Local Variables:
# time-stamp-pattern:"8/^\\#\\+date:%4y-%02m-%02d %02H:%02M$"
# eval: (org-indent-mode)
# eval: (electric-quote-local-mode)
# End:
